[{"content":"View it on Github\nThe Tragedy Every data hoarder\u0026rsquo;s nightmare â€” no, not hard drive corruption (though that\u0026rsquo;s up there), but something equally as chilling: scrambled file names. Imagine your meticulously curated music collection became a cryptic mess of unidentifiable tracks!\n1 2 3 4 5 6 7 8 9 10 11 12 $ ls my-lifes-mixtape/ 1027098972255028133.mp3 1027167747674130870.mp3 1027290277583497446.mp3 1031191161722692691.mp3 -1062590078858828842.mp3 1098949889736289958.mp3 -1131991569406517012.mp3 1172902445231424744.mp3 1173619643127455402.mp3 -1205293020995236198.mp3 ... This is the horror I found myself in when revisiting my old collection of music. Somehow, the titles became unidentifiable indexed numbers. With hundreds of files like this, playing and identifying them all by hand would take an unreasonable amount of time. The only real choice to deal with this issue is to reach for the lazy programmer\u0026rsquo;s playbook.\nLet\u0026rsquo;s try to automate this.\nThe Lost Title Format To begin, it\u0026rsquo;s important to identify a target file format that would satisfy my data collection needs. An ideal file name format for this use case would include the title of the track as well as the artist name.\nTrack title - Artist.extension\nMore song info could be collected, but with the title and artist name the files can at least be identified.\nThere are a few good ways to collect track info: It\u0026rsquo;s possible some files have their track info embedded in metadata. In this case, we can inspect the file for this metadata and determine if the track name and artist name are preserved. Identify the songs automatically based on audio data, this could be done with some song detection API. Extracting Metadata with ExifTool By inspecting file metadata (with the tool exiftool), we can determine if track details are still present on any music files by parsing for Title and Artist details embedded within them.\nAn example of inspecting a file:\n1 2 3 4 5 6 7 8 9 10 11 12 $ exiftool 8810117537767368468.mp3 ExifTool Version Number : 12.40 File Name : 8810117537767368468.mp3 Directory : . File Size : 7.8 MiB File Modification Date/Time : 2017:04:12 12:51:55-04:00 File Access Date/Time : 2024:01:28 02:26:09-05:00 File Inode Change Date/Time : 2017:04:12 12:51:55-04:00 # ... Title : Mocki - Weekend (Jai Wolf Remix) Artist : Underground Charisma # ... Here we can see an example of a file with Title and Artist details preserved. The file names for these are relatively easy to resolve, and we can setup a simple bash script to correct them.\nParse metadata and request a rename First let\u0026rsquo;s automate retrieving our desired tags. We\u0026rsquo;ll create a bash script leveraging exiftool to automate this.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Just process the first command line argument as single file, and if there are # no arguments then fail file=\u0026#34;${1:?}\u0026#34; title=\u0026#34;\u0026#34; artist=\u0026#34;\u0026#34; if exiftool \u0026#34;${file}\u0026#34; | grep -q \u0026#39;Title\u0026#39;; then title=$(exiftool -Title -m -p \u0026#39;${Title}\u0026#39; \u0026#34;${file}\u0026#34;) fi if exiftool \u0026#34;${file}\u0026#34; | grep -q \u0026#39;Artist\u0026#39;; then artist=$(exiftool -Artist -m -p \u0026#39;${Artist}\u0026#39; \u0026#34;${file}\u0026#34;) fi To ensure name change actions are verified by a user directly, we can ask the user if the would like to rename the file based on the given data. Ensure the file extension is preserved using the bash substring removal pattern.\n1 2 3 4 5 6 7 8 9 10 11 12 # The expression removes everything but the file extension file_ext=\u0026#34;${file##*.}\u0026#34; echo \u0026#34;${file} : ${title} - ${artist}.${file_ext}\u0026#34; echo \u0026#34;rename file? (y/N)\u0026#34; read answer if [[ \u0026#34;${answer}\u0026#34; = \u0026#34;y\u0026#34; ]] || [[ \u0026#34;${answer}\u0026#34; = \u0026#34;Y\u0026#34; ]]; then mv \u0026#34;${file}\u0026#34; \u0026#34;${title} - ${artist}.${file_ext}\u0026#34; else echo \u0026#34;${file} not renamed\u0026#34; fi Edge case: Handle -filenames Our script works - almost. There is an edge case that currently breaks it however. Files that begin with a -, such as -1131991569406517012.mp3 cause an interesting error:\n1 2 Invalid TAG name: \u0026#34;1131991569406517012.mp3\u0026#34; No file specified The error appears to imply exiftool is parsing the filename as an additional command line option due to the - signifying an option. To eliminate this issue, exiftool must be told where command line options end, and where file arguments begin. This can be accomplished by including -- within the command call.\n1 2 3 if exiftool -- \u0026#34;${file}\u0026#34; | grep -q \u0026#39;Title\u0026#39;; then title=$(exiftool -Title -m -p \u0026#39;${Title}\u0026#39; -- \u0026#34;${file}\u0026#34;) fi Final Script Before we finalize this script, let\u0026rsquo;s add the functionality to handle all input CLI arguments as filenames. This will allow us to do simple calls such as ./rename_using_tags.sh *.mp3 within a target directory to completely repair corrupt file names!\nDry run capabilities are also included below, allowing test runs to substitute mv with echo instead. Dry run is activated by calling -d before including filenames. for example: ./rename_using_tags.sh -d *.mp3. This can allow us to verify our script will function as expected before running any irreversible commands.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/bin/bash MV_CMD=mv # Dry run if [[ \u0026#34;$1\u0026#34; = \u0026#34;-d\u0026#34; ]]; then MV_CMD=echo shift fi for file in \u0026#34;$@\u0026#34;; do title=\u0026#34;\u0026#34; artist=\u0026#34;\u0026#34; if exiftool -- \u0026#34;${file}\u0026#34; | grep -q \u0026#39;Title\u0026#39;; then title=$(exiftool -Title -m -p \u0026#39;${Title}\u0026#39; -- \u0026#34;${file}\u0026#34;) else continue fi if exiftool -- \u0026#34;${file}\u0026#34; | grep -q \u0026#39;Artist\u0026#39;; then artist=$(exiftool -Artist -m -p \u0026#39;${Artist}\u0026#39; -- \u0026#34;${file}\u0026#34;) fi file_ext=\u0026#34;${file##*.}\u0026#34; echo \u0026#34;${file} : ${title} - ${artist}.${file_ext}\u0026#34; echo \u0026#34;rename file? (y/N)\u0026#34; read answer if [[ \u0026#34;${answer}\u0026#34; = \u0026#34;y\u0026#34; ]] || [[ \u0026#34;${answer}\u0026#34; = \u0026#34;Y\u0026#34; ]]; then file_ext=\u0026#34;${file##*.}\u0026#34; $MV_CMD -- \u0026#34;${file}\u0026#34; \u0026#34;${title} - ${artist}.${file_ext}\u0026#34; else echo \u0026#34;${file} not renamed\u0026#34; fi done Identifying tracks automatically with the ShazamIO API What about the songs without any useful metadata to be found? Only inspecting the audio itself could help identify the track. For this case, an identification API such as shazamio can be leveraged.\nTest basic usage of ShazamIO First let\u0026rsquo;s implement a basic usage of ShazamIO (referencing their example script). With this, we can experiment and determine the functionality required to identify and retrieve our track data. ShazamIO is an asynchronous API, and thus we\u0026rsquo;ll need to leverage coroutines to utilize it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import sys import asyncio from shazamio import Shazam, Serialize # We\u0026#39;ll pass in the song name via the first command line argument song = sys.argv[1] # Init API shazam = Shazam() # Generates a coroutine for us to run asynchronously coroutine = shazam.recognize_song(song) # Run and wait for coroutine to return out = asyncio.run(coroutine) # Serialize the out data buffer into a readable format serialized = Serialize.full_track(out) # Print to inspect available values if serialized is None: print(\u0026#34;Song \u0026#34;, song, \u0026#34; not found\u0026#34;) else: print(serialized) From this quick example script, we can parse the returned data and determine the useful fields for our utility.\nOutput:\n1 2 3 4 5 6 7 8 9 10 11 12 13 ResponseTrack( tag_id=UUID(\u0026#39;18f05c79-9e5c-40ba-b2af-5207c37159be\u0026#39;), retry_ms=None, location=LocationModel(accuracy=0.01), matches=[MatchModel(id=\u0026#39;683393722\u0026#39;, offset=92.227828125, time_skew=-0.06451672, frequency_skew=-0.009831846, channel=None)], timestamp=1708139612620, timezone=\u0026#39;Europe/Moscow\u0026#39;, track=TrackInfo(key=683393722, title=\u0026#39;Let It Enfold You\u0026#39;, subtitle=\u0026#39;Senses Fail\u0026#39;, artist_id=\u0026#39;42\u0026#39;, shazam_url=\u0026#39;https://www.shazam.com/track/42\u0026#39;, ... Great, the title is an available field, and subtitle references the Artist of the song. We can create our parsing algorithm to retrieve this info and rename the song files.\nEncapsulate within an identify function Let\u0026rsquo;s create an identify function to retrieve the Shazam data, parse it, and return the desired file name. Making this function asynchronous will help us later.\nFor error scenarios, we\u0026rsquo;ll use Python exceptions. These can be caught by the calling function, which can determine how to proceed with the song file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 async def identify(song_file): title = \u0026#34;\u0026#34; subtitle = \u0026#34;\u0026#34; song_file_extension = os.path.splitext(song_file)[1] shazam = Shazam() random.seed() try: out = await shazam.recognize_song(song_file) except Exception as e: raise Exception(f\u0026#34;Shazam could not recognize the song from file {song_file}\u0026#34;) serialized = Serialize.full_track(out) if serialized.track.title is None: raise Exception(f\u0026#34;Song name of {song_file} not found\u0026#34;) else: title = serialized.track.title if serialized.track.subtitle is None: raise Exception(f\u0026#34;Song artist of {song_file} not found\u0026#34;) else: subtitle = serialized.track.subtitle # Return our desired naming format return title + \u0026#34; - \u0026#34; + subtitle + song_file_extension Create a process to handle the main execution logic We\u0026rsquo;ll create a main process to handle the control flow of our tool. Because the ShazamIO API takes some time to identify the song, our plan is to use several workers at the same time to quickly find and rename the many files given to our application.\nHere, multiple identifier workers will be created. These workers will concurrently handle identifying all songs, and populating our async song queue when found.\nFor our limited amount of workers to traverse the long list of input files efficiently, a stride based setup can be leveraged. Each worker thread is given a start index and a stride length based on the total number of workers. Using this method allows for workers to process multiple songs by striding through the array without stepping on each other.\nHere is example of a stride based traversal to illustrate this method:\n1 2 3 4 5 6 7 workers[3] array[12] # Process elements workers[1] : 0, 3, 6, 9 workers[2] : 1, 4, 7, 10 workers[3] : 2, 5, 8, 11 There will be just one renamer worker however. This single worker handles taking files from the async queue and renaming them. This way, we keep the renaming part simple and sequential.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 async def process(file_list, num_coroutines): song_name_queue = asyncio.Queue() # Create producer tasks, each with a different start index and the same stride identifiers = [ asyncio.create_task( identifier_coroutine(song_name_queue, file_list, i, num_coroutines) ) for i in range(num_coroutines) ] renamer = asyncio.create_task(renamer_coroutine(song_name_queue)) # Wait for all songs to be identified await asyncio.gather(*identifiers) # Wait until the queue is fully processed await song_name_queue.join() # Cancel the consumer task as it\u0026#39;s intentionally an infinite loop renamer.cancel() Create coroutines to handle identifying songs and renaming files Here we implement the identifier and renamer coroutines. As mentioned before, the identifier_coroutine will utilize a stride based implementation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 async def identifier_coroutine(queue, data, start_index, stride): for i in range(start_index, len(data), stride): item = data[i] try: song_title = await identify(item) await queue.put([item, song_title]) except Exception as e: print(e) async def renamer_coroutine(queue): while True: result = await queue.get() file = result[0] new_name = result[1] print(f\u0026#34;renaming {file} to {new_name}\u0026#34;) os.rename(file, new_name) # Notify the queue that the item has been processed queue.task_done() The throttling problem The Shazam API unfortunately puts a cap on how many requests you can make in a certain amount of time. If this limit is exceeded, any additional requests will time out for a while. To avoid hitting this limit, we can make our identify function wait for a random amount of time before trying again. This way, not all of our identifier workers will send requests at the same time. Spacing out requests with this method after the timeout ends will help prevent overloading the Shazam API again with multiple requests at once.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 async def identify(song_file): title = \u0026#34;\u0026#34; subtitle = \u0026#34;\u0026#34; song_file_extension = os.path.splitext(song_file)[1] shazam = Shazam() random.seed() max_attempts = 20 out = None # Shazam throttles song requests, so retry with sleep if exception occurs for attempt in range(max_attempts): try: out = await shazam.recognize_song(song_file) break except Exception as e: random_sleep_time = random.randint(1, 30) await asyncio.sleep(random_sleep_time) if out is None: raise Exception(f\u0026#34;Shazam could not recognize the song from file {song_file}\u0026#34;) serialized = Serialize.full_track(out) ... Final Result Some songs are still misidentified by ShazamIO, but for most cases this combo of tools fixed my music library.\n1 2 3 4 5 6 Fur Elise - Ludwig van Beethoven.mp3 Sandstorm - Darude.mp3 Canon in D - Johann Pachelbel.mp3 Baby - Justin Bieber.mp3 River Flows In You - Yiruma.mp3 Never Gonna Give You Up - Rick Astley.mp3 Additional Thoughts and Improvements These tools prompt the user before every file name change, but this could quickly become tedious. Instead, implementing a -y option to skip prompts could be effective. For review, adding the option to generate a log of file name changes could also help if some name change occurred that was not intended. Using an API like ShazamIO that connects to a commercially owned service is a weak point, and creates issues such as the throttling problem above. Using a different API, or replacing with a deep learning model that can run on local hardware or private servers would be preferred. At the time of writing this, I could not find a well developed and updated song identification model, but something like this should be feasible with current deep learning technology. ","date":"2024-03-09T00:00:00Z","image":"http://localhost:1313/p/a-programmers-melody-creating-a-tool-to-fix-my-song-files/cover_hua05a2813d4e00fad08fc44264f57e051_2454800_120x120_fill_box_smart1_3.png","permalink":"http://localhost:1313/p/a-programmers-melody-creating-a-tool-to-fix-my-song-files/","title":"A Programmer's Melody: Creating a Tool to Fix My Song Files"},{"content":"The Discovery Recently while performing some unimportant updates to a C++ codebase, I noticed an interesting issue arise.\nWhen attempting to signal some worker threads to complete, they refused to end. After investigating extensively, I could not understand how my changes had caused this issue. The modifications weren\u0026rsquo;t even touching these zombie threads.\nAfter inspecting the threads in question further, a realization hit me - the compiler had optimized out a boolean.\nThis snippet of code has a bug 1 2 3 4 5 6 7 8 9 10 11 bool run = true; std::thread workerThread([\u0026amp;] { while(run) { doWork(); } }); std::this_thread::sleep_for(std::chrono::seconds(1)); run = false; workerThread.join(); Do you notice anything wrong here?\nIf you add this snippet to some test code, it most likely will compile and run just as desired. Probably, after setting run to false, it will end workerThread and allow .join() to complete.\nHowever, if you\u0026rsquo;re unlucky enough you might compile and discover the thread never ends. This interesting issue is because passing the bool to the thread\u0026rsquo;s lambda function, even by reference, causes undefined behavior.\nAccording to the compiler, the run variable could be safely optimized out, as clearly the while loop was always meant to be while(true).\nUndefined Behavior: 90% of the time it works every time Undefined behavior is a tricky topic in C and C++. A program might \u0026ldquo;get away\u0026rdquo; with running bug free while containing undefined behavior.\nHowever, the entire program is technically meaningless. Since the results generated from the program are non-deterministic, it may work flawlessly one day, then start producing erroneous results the next.\nUB is also tricky to detect. There are static analysis tools available, but even they struggle to detect all instances. It is left to the programmer to understand the cost of the code they write and to understand the repercussions of adding it to a codebase, including whether or not it has the potential to introduce undefined behavior.\nA variable of a primitive data type accessed by multiple threads without using a mutex or semaphore is undefined behavior This is because primitive types in C++ do not have several characteristics required for safe multithreaded access. These types do not have a specified memory order or synchronization mechanism. This means when two threads attempt to access a single variable of these types, there is no defined way to ensure a data race does not occur.\nThe Solution: Atomics There are several ways to fix the issue. You could do proper locking and synchronize the main and worker threads when accessing run. Another solution that may provide better performance is assigning multithreaded behavior to the variable itself. This can be done by wrapping the primitive type in an atomic variable. After doing so, the variable can be used like any other bool, except now we have removed the undefined behavior!\nrun is now thread safe 1 2 3 4 5 6 7 8 9 10 11 std::atomic\u0026lt;bool\u0026gt; run {true}; std::thread workerThread([\u0026amp;] { while(run) { doWork(); } }); std::this_thread::sleep_for(std::chrono::seconds(1)); run = false; workerThread.join(); Why not use Volatile? For those with experience in C, a tempting solution might be to use the qualifier volatile. At first glance, this makes sense. If a variable is marked volatile, you can avoid those pesky compiler optimizations that occur as a result of undefined behavior.\nHowever, after digging a little one can find some interesting details on this proposed solution. The volatile qualifier has its own flavor of undefined behavior. Namely, a volatile variable is not guaranteed to have synchronization or a specified memory ordering.\nAny UB results in the entire program becoming undefined Without these properties, accessing a volatile variable concurrently is undefined behavior. As discussed previously, introducing convenient UB into a program is dangerous and can have unforeseen impacts later in a program\u0026rsquo;s lifecycle.\nReferences / Further Reading https://cryptoservices.github.io/fde/2018/11/30/undefined-behavior.html https://en.cppreference.com/w/cpp/atomic/atomic https://en.cppreference.com/w/c/language/volatile ","date":"2023-07-18T00:00:00Z","image":"http://localhost:1313/p/sneaky-undefined-behavior-in-c-multithreading/cover_hu42fdf4c9cab346e419a04776831c774b_1480353_120x120_fill_box_smart1_3.png","permalink":"http://localhost:1313/p/sneaky-undefined-behavior-in-c-multithreading/","title":"Sneaky Undefined Behavior in C++ Multithreading"}]